# Project Learnings

## Fresh Framework Initialization

- Fresh 2.0.0 is not yet available on deno.land/x. The latest stable version is Fresh 1.7.3, which works perfectly for this project.
- Fresh project structure requires:
  - `deno.json` with Fresh imports and tasks
  - `dev.ts` for development server
  - `main.ts` for production server
  - `fresh.config.ts` for configuration
  - `fresh.gen.ts` for route manifest (auto-generated)
  - `routes/` directory for page routes
  - `static/` directory for static assets
- The dev server starts on localhost:8000 by default
- Fresh uses Preact for components and supports TypeScript out of the box
- The `deno task start` command runs the development server with hot reload

## Database Configuration

- PostgreSQL client library: Use `deno.land/x/postgres@v0.17.0` for PostgreSQL connections in Deno
- Connection pooling: The postgres library provides a Pool class that handles connection pooling automatically
- Environment variables: Access via `Deno.env.get()` - no need for dotenv library in Deno
- Database module location: Created `lib/db.ts` for database utilities following common project structure
- Type safety: Use generic types with `query<T>()` for type-safe query results
- Error handling: Always check if errors are instances of Error before accessing `.message` property
- Connection pool: Singleton pattern used for pool instance to ensure single pool per application
- Test script: Created `scripts/test-db.ts` for verifying database connectivity and pooling

## Database Migrations

- Migration directory: Created `migrations/` directory for SQL migration files
- Migration naming: Use numbered prefix (001_, 002_, etc.) for execution order
- Migration runner: Created `scripts/migrate.ts` for running migrations with tracking
- Migration tracking: Uses `migrations` table to track executed migrations and prevent duplicates
- Migration execution: Migrations run in transactions with rollback on failure
- File operations: Use Deno built-in APIs (`Deno.readDir`, `Deno.readTextFile`) instead of std library for file operations
- Migration tasks: Added `deno task migrate` for running migrations, `deno task test:users` for testing users table
- Migration rollback support: Added up/down migration support using `-- down` marker to separate up and down SQL sections in migration files
- Rollback functionality: Implemented `rollbackMigration()` function to execute down migrations and remove migration from tracking table
- Rollback commands: Added `deno task migrate:rollback` to rollback last migration, or `deno task migrate:rollback <name>` to rollback specific migration
- Migration parsing: Migration files can contain both up and down sections separated by `-- down` marker, or just up section (backward compatible with existing migrations)
- Rollback validation: Rollback fails if migration doesn't have a down section, preventing partial rollbacks
- Users table: Includes id (UUID), email (unique), display_name, avatar_url, preferences (JSONB), created_at, updated_at with automatic timestamp triggers
- Content table: Uses PostgreSQL enum type (content_type) for type safety with values: movie, tv, documentary
- Content table structure: Includes tmdb_id (unique integer), type (enum), title, overview, release_date, poster_path, backdrop_path, metadata (JSONB), and timestamps
- Enum types: Created using `CREATE TYPE` syntax before table creation, referenced in column definition as `content_type NOT NULL`
- Test scripts: Follow consistent pattern - verify structure, test inserts, test retrievals, test queries. Created `scripts/test-content-table.ts` and added `deno task test:content`
- User_content table: Junction table for many-to-many relationship between users and content with status tracking
- User_content status enum: Created `user_content_status` enum with values: watched, to_watch, favourite
- Foreign key constraints: Use `REFERENCES table(column) ON DELETE CASCADE` for automatic cleanup when parent records are deleted
- Unique constraints: Use `UNIQUE(column1, column2)` syntax for composite unique constraints on junction tables
- Rating column: Use `NUMERIC(3, 1)` for ratings with CHECK constraint to enforce 0-10 range
- Cascade delete testing: Test cascade behaviour by deleting parent records and verifying child records are automatically deleted
- Junction table indexes: Create indexes on foreign key columns and commonly queried columns (status, watched_at) for performance
- Lists tables: Created lists table for user collections and list_items junction table for many-to-many relationship with content
- Lists table structure: Includes user_id (FK to users), name, description, is_public (boolean), and timestamps with cascade delete from users
- List_items table structure: Includes list_id (FK to lists), content_id (FK to content), position (integer for ordering), with cascade delete from both parent tables
- List ordering: Use integer position column with index on (list_id, position) for efficient ordered queries
- Composite unique constraint: Use UNIQUE(list_id, content_id) to prevent duplicate content in the same list
- Test script pattern: Follow consistent structure - verify table structure, test inserts, test ordering, test constraints, test cascade deletes
- Tags tables: Created tags table for user-defined tags and content_tags junction table for many-to-many relationship with content
- Tags table structure: Includes user_id (FK to users), name, colour (VARCHAR(7) for hex colour codes), and timestamps with cascade delete from users
- Tags unique constraint: Use UNIQUE(user_id, name) to prevent duplicate tag names per user (allows same tag name for different users)
- Content_tags table structure: Includes tag_id (FK to tags), content_id (FK to content), with cascade delete from both parent tables
- Content_tags unique constraint: Use UNIQUE(tag_id, content_id) to prevent duplicate tag applications to the same content
- Tag colour default: Use VARCHAR(7) for hex colour codes (e.g., #3B82F6) with default value for consistent styling
- Multiple tags on content: Test applying multiple tags to a single content item to verify many-to-many relationship works correctly
- Streaming services tables: Created streaming_services table for service metadata and content_streaming junction table for availability tracking
- Streaming services table structure: Includes name (unique), logo_url, deep_link_template for generating deep links to streaming apps
- Content_streaming table structure: Includes service_id (FK to streaming_services), content_id (FK to content), region (VARCHAR(10)), type (enum: subscription/rent/buy), price (NUMERIC), available_from/until dates, with cascade delete from both parent tables
- Streaming type enum: Created streaming_type enum with values: subscription, rent, buy for categorising availability types
- Composite unique constraint: Use UNIQUE(service_id, content_id, region, type) to prevent duplicate availability entries for the same service/content/region/type combination
- Region-based availability: Store region as VARCHAR(10) to support ISO country codes (US, GB, CA, AU, DE, FR, etc.) for region-specific streaming availability
- Service seeding: Seed common streaming services (Netflix, Disney+, Amazon Prime Video, Apple TV+, HBO Max, Hulu, Paramount+, Peacock, BBC iPlayer, ITV Hub) in migration using ON CONFLICT DO NOTHING to allow re-running migrations
- Deep link templates: Store template strings in streaming_services.deep_link_template for generating deep links to content on streaming platforms
- Availability dates: Include available_from and available_until DATE columns for tracking time-limited availability (e.g., content leaving soon)

## Authentication & Session Management

- JWT library: Use `deno.land/x/djwt@v3.0.2` for JWT signing and verification in Deno
- JWT secret: Store JWT_SECRET in environment variables, use crypto.subtle.importKey for HMAC-SHA256 key generation
- Session token structure: Include userId, email, iat (issued at), and exp (expiration) in JWT payload
- Token expiration: Default to 7 days (604800 seconds) for session tokens
- Cookie security: Use HttpOnly flag to prevent JavaScript access (XSS protection), SameSite=Lax for CSRF protection, Secure flag in production
- Cookie management: Set cookies via Set-Cookie header, read from Cookie header, clear by setting Max-Age=0
- Session middleware: Extract token from cookies, verify JWT, attach session to handler context state
- Token verification: Verify token signature and expiration, reject invalid or expired tokens with clear error messages
- Type safety: Use interface for SessionPayload, validate payload structure after verification to ensure type safety

## User Authentication - Email/Password Signup

- Password hashing: Use `deno.land/x/bcrypt@v0.4.1` for password hashing in Deno
- Password storage: Store bcrypt hash in `password_hash` column (VARCHAR(255)) in users table
- Password validation: Enforce minimum 8 characters on both client (HTML minLength) and server side
- Email validation: Validate email format using regex pattern on server side, normalise to lowercase before storage
- User creation: Use database transaction to ensure atomic user creation with password hash
- Duplicate email check: Query existing users before attempting insert to prevent duplicate email registration
- API routes in Fresh: Create API handlers by exporting a `handler` object with HTTP method handlers (GET, POST, etc.) from routes in `routes/api/` directory
- Form handling: Use FormData API to extract form values from POST requests in Fresh handlers
- Redirect after POST: Use 303 See Other status code with Location header for redirect after successful POST (prevents resubmission on refresh)
- Session creation: Create JWT session token immediately after user creation and set secure cookie before redirecting

## User Authentication - Email/Password Login

- Login page: Create login page at `routes/login.tsx` with form matching signup page structure
- Login API handler: Create handler at `routes/api/login.ts` following same pattern as signup handler
- Password verification: Use `verifyPassword()` function from `lib/auth/password.ts` to compare submitted password with stored bcrypt hash
- Bcrypt hash format: Bcrypt hashes start with `$2a$`, `$2b$`, or `$2y$` followed by cost factor and are typically 60 characters long
- Password hashing test script: Created `scripts/test-password-hashing.ts` to verify passwords are hashed before storage, stored as bcrypt format (not plaintext), and login works with correct/incorrect passwords, added `deno task test:password-hashing` to deno.json
- User lookup: Query users table by email (normalised to lowercase) to find existing user
- Authentication errors: Return generic "Invalid email or password" message for both non-existent users and incorrect passwords (prevents user enumeration)
- Error status codes: Use 401 Unauthorized for authentication failures, 400 for validation errors
- Session creation on login: Create JWT session token and set cookie after successful password verification, same as signup flow

## Route Protection & Authentication

- Protected routes in Fresh: Export a `handler` object with GET/POST/etc methods from route files to add middleware logic
- Route protection pattern: Check session in handler, redirect to login with return URL if unauthenticated, render page if authenticated
- Return URL handling: Preserve original destination in `returnTo` query parameter, validate to prevent open redirects (must start with "/")
- Login redirect flow: Extract `returnTo` from form data after login, default to "/dashboard" if not provided, redirect user back to original destination
- API route protection: Use `requireAuthForApi()` helper function to check authentication and return 401 JSON response for unauthenticated requests
- Redirect status codes: Use 302 Found for redirects to login page, 303 See Other for redirects after POST requests
- Session checking: Use `getSessionFromRequest()` from middleware to extract and validate session token in route handlers

## TMDB API Integration

- TMDB API client: Created `lib/tmdb/client.ts` for TMDB API interactions with rate limiting and error handling
- API key configuration: Store TMDB_API_KEY in environment variables, accessed via `Deno.env.get()`
- Rate limiting: Implemented sliding window rate limiter to enforce 50 requests per second limit (TMDB free tier limit)
- Rate limiter pattern: Use singleton RateLimiter class with request timestamp tracking, automatically waits when limit reached
- TMDB API base URL: Use `https://api.themoviedb.org/3` as base URL for all API requests
- API error handling: TMDB returns JSON with `success: false` and `status_code`/`status_message` fields for errors
- Error code 34: TMDB status code 34 indicates resource not found (e.g., invalid movie ID)
- Movie details interface: Define TypeScript interface for MovieDetails with required fields (id, title, overview, release_date, poster_path, backdrop_path, vote_average, vote_count, runtime, genres)
- Request function: Generic `request<T>()` function handles rate limiting, API key injection, parameter encoding, and error parsing
- Test script pattern: Created `scripts/test-tmdb-client.ts` following same pattern as other test scripts - verify functionality, test error cases, test rate limiting
- Environment variable documentation: Added TMDB_API_KEY to `.env.example` with instructions to get API key from TMDB settings
- Movie search function: Created `searchMovies()` function in TMDB client that accepts query string and page number, returns paginated results
- TMDB search endpoint: Use `/search/movie` endpoint with `query` and `page` parameters for movie search
- Search response mapping: TMDB search returns `{ page, results[], total_pages, total_results }` structure, map results to internal Content model with type 'movie'
- Content model mapping: Map TMDB movie search results to internal Content interface with tmdb_id, type: 'movie', title, overview, release_date, poster_path, backdrop_path, and metadata object
- Pagination validation: Validate page number is positive integer, validate query is non-empty string before making API request
- Search test script: Created `scripts/test-tmdb-search.ts` to test search functionality, pagination, and error handling, added `deno task test:tmdb-search` to deno.json
- TV show search function: Created `searchTv()` function in TMDB client that accepts query string and page number, returns paginated results with type 'tv'
- TMDB TV search endpoint: Use `/search/tv` endpoint with `query` and `page` parameters for TV show search
- TV show field mapping: TMDB TV shows use `name` field instead of `title`, and `first_air_date` instead of `release_date` - map these to internal Content model fields
- TV search response mapping: TMDB TV search returns same structure as movie search but with TV-specific fields, map to Content model with type 'tv'
- TV content type verification: Test script verifies all search results have type 'tv' to ensure correct mapping
- Content details functions: Created `getMovieDetails()` and `getTvDetails()` functions that fetch full content details including cast, crew, and images
- TMDB append_to_response parameter: Use `append_to_response=credits,images` query parameter to include credits and images in a single API request
- Credits structure: TMDB credits include `cast[]` array with cast members (name, character, profile_path) and `crew[]` array with crew members (name, job, department, profile_path)
- Images structure: TMDB images include `posters[]` array and `backdrops[]` array, each containing image objects with file_path, width, height, aspect_ratio, vote_average, vote_count
- Cast member interface: Define CastMember interface with id, name, character, order, profile_path fields
- Crew member interface: Define CrewMember interface with id, name, job, department, profile_path fields
- Image interface: Define Image interface with file_path, width, height, aspect_ratio, vote_average, vote_count fields
- MovieDetails interface: Extended MovieDetails interface to include optional `credits?: Credits` and `images?: Images` fields
- TvDetails interface: Created TvDetails interface similar to MovieDetails but with TV-specific fields (name instead of title, first_air_date instead of release_date, episode_run_time instead of runtime)
- Content details test script: Created `scripts/test-tmdb-content-details.ts` to test fetching movie and TV details, verify credits and images are included, test error handling, added `deno task test:tmdb-content-details` to deno.json

## Security - SQL Injection Prevention

- Parameterised queries: All database queries use parameterised statements with $1, $2, etc. placeholders to prevent SQL injection attacks
- Query function security: The `query()` function in `lib/db.ts` uses `queryObject()` with separate `text` and `args` parameters, ensuring user input is never concatenated into SQL strings
- Code review verification: All queries in routes/api/ (login.ts, signup.ts) use parameterised queries with placeholders
- Test script: Created `scripts/test-sql-injection-protection.ts` to verify SQL injection payloads are safely handled as literal strings, added `deno task test:sql-injection` to deno.json
- Documentation: Added security documentation to `query()` function with examples of correct (parameterised) and incorrect (concatenated) usage patterns
- Best practice: Never concatenate user input directly into SQL strings - always use parameterised queries with placeholders

## Security - XSS Prevention

- HTML escaping utility: Created `lib/security/xss.ts` with `escapeHtml()`, `escapeHtmlAttribute()`, and `escapeJsString()` functions to sanitise user input
- HTML escaping: Escapes HTML special characters (< > & " ') to their HTML entity equivalents (&lt; &gt; &amp; &quot; &#x27;) to prevent XSS attacks
- Preact automatic escaping: Preact/React automatically escapes content in JSX, but utilities should be used when working with raw HTML strings or setting HTML attributes from user input
- Test script: Created `scripts/test-xss-prevention.ts` to verify XSS attack vectors (script tags, event handlers, JavaScript protocols) are neutralised, added `deno task test:xss` to deno.json
- XSS attack vectors tested: Script tags, event handlers (onerror, onload, onfocus), JavaScript protocol injection, iframe injection, and various HTML injection techniques
- Edge cases: Functions handle null, undefined, and empty strings gracefully by returning empty string
- Best practice: Always escape user-generated content before displaying in HTML, especially when using dangerouslySetInnerHTML or setting HTML attributes dynamically

## Authentication - Google OAuth

- OAuth flow: Implemented OAuth 2.0 authorization code flow with Google (initiation endpoint redirects to Google, callback endpoint handles response)
- OAuth configuration: Store GOOGLE_OAUTH_CLIENT_ID and GOOGLE_OAUTH_CLIENT_SECRET in environment variables
- OAuth initiation endpoint: Created `/api/auth/google` endpoint that generates Google OAuth URL with client ID, redirect URI, scopes (openid email profile), and state parameter
- OAuth callback endpoint: Created `/api/auth/google/callback` endpoint that exchanges authorization code for access token, fetches user profile, and creates/logs in user
- State parameter: Use base64-encoded JSON to store returnTo URL in state parameter for CSRF protection and redirect handling
- Redirect URI: Construct redirect URI dynamically from request origin to support different environments (localhost, staging, production)
- Token exchange: Exchange authorization code for access token using POST request to `https://oauth2.googleapis.com/token` with client credentials
- User profile fetching: Fetch user profile from `https://www.googleapis.com/oauth2/v2/userinfo` using access token to get email, name, picture
- Email verification: Verify `verified_email` field from Google profile before creating/logging in user
- User lookup: Check for existing users by google_id or email to handle both new signups and existing user logins
- User creation: Create new user with Google profile data (email, google_id, display_name, avatar_url) when user doesn't exist
- User linking: Update existing users with google_id if they sign in with Google but already have an account with that email
- Profile updates: Update display_name and avatar_url from Google profile if available and not already set
- Database migration: Added google_id column (VARCHAR(255)) to users table with index for OAuth user lookup
- UI integration: Added "Continue with Google" buttons to login and signup pages with Google logo SVG icon and divider styling
- OAuth button styling: Use Tailwind classes for consistent styling with white background, gray border, and hover states matching existing form buttons
- Error handling: Handle OAuth errors (missing code, email not verified, token exchange failures) with redirects to login page with error query parameters
- Session creation: Create JWT session token and set secure cookie after successful OAuth authentication, same as email/password flow

## Authentication - Logout

- Logout endpoint: Created `/api/logout` endpoint that clears session cookie and redirects to homepage
- Logout methods: Support both POST (form submission) and GET (link navigation) requests for logout
- Cookie clearing: Use `clearSessionCookie()` function to set session cookie with Max-Age=0, matching same security flags (HttpOnly, SameSite, Secure) as session cookie creation
- Secure flag consistency: Ensure logout cookie clearing includes Secure flag when in production environment, matching the pattern used in `setSessionCookie()`
- Logout UI: Add logout button to dashboard page with form POST to `/api/logout` endpoint
- Redirect after logout: Redirect to homepage ("/") after clearing session cookie
- Session validation: After logout, protected routes will redirect to login since session cookie is cleared

## TMDB API - Watch Providers

- Watch providers endpoints: Use `/movie/{movie_id}/watch/providers` and `/tv/{tv_id}/watch/providers` endpoints to fetch streaming availability data
- Watch providers response structure: TMDB returns a `results` object where keys are ISO 3166-1 country codes (e.g., "US", "GB", "CA", "AU", "DE", "FR"), and each country has `flatrate` (subscription), `rent`, `buy`, `ads`, and `free` arrays
- Provider structure: Each provider includes `provider_id`, `provider_name`, `logo_path`, `display_priority`, and other metadata fields
- Region filtering: Created `filterWatchProvidersByRegion()` function to extract and categorise providers for a specific region from the full response
- Supported regions: Defined `SUPPORTED_REGIONS` constant array with ["US", "GB", "CA", "AU", "DE", "FR"] for type-safe region handling
- Categorisation: Providers are categorised into `subscription` (flatrate), `rent`, `buy`, `ads`, and `free` arrays for easy consumption
- Convenience functions: Created `getMovieWatchProvidersByRegion()` and `getTvWatchProvidersByRegion()` functions that combine fetching and filtering in a single call
- Null handling: Functions return `null` if no providers are available for the specified region (not an error condition)
- Type safety: Created TypeScript interfaces (`WatchProvider`, `RegionWatchProviders`, `WatchProvidersResponse`, `CategorisedWatchProviders`) for type-safe handling of watch provider data

## TMDB API - Redis Caching Layer

- Redis cache module: Created `lib/cache/redis.ts` for Redis/Upstash caching of TMDB API responses to reduce API calls and improve performance
- Upstash REST API: Use Upstash Redis REST API with POST requests containing Redis command arrays (e.g., ["GET", key], ["SETEX", key, ttl, value], ["DEL", key])
- Cache configuration: Store UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN in environment variables, cache gracefully degrades if not configured
- Cache key generation: Generate cache keys from endpoint and sorted parameters (e.g., "tmdb:/movie/550:append_to_response=credits,images") for consistent key generation
- Cache entry structure: Store cache entries as JSON objects with `{ data: T, expiresAt: number }` to track expiration times
- Cache TTL: Default cache TTL is 24 hours (86400 seconds) for TMDB API responses, configurable per request
- Cache integration: Integrated cache wrapper into TMDB client `request()` function - checks cache first, falls back to API if cache miss, stores successful responses
- Graceful degradation: Cache failures (Redis unavailable, network errors) are logged as warnings but don't break API functionality - app continues without cache
- Cache expiry handling: Cache entries include expiration timestamp, expired entries are automatically deleted when accessed
- Error caching: Don't cache API errors (only cache successful responses) to allow retry of transient failures
- Cache test script: Created `scripts/test-tmdb-cache.ts` to test cache hits, cache expiry, and graceful degradation, added `deno task test:tmdb-cache` to deno.json
- Singleton pattern: Use singleton RedisCache instance for consistent cache access across the application

# Project Learnings

## Fresh Framework Initialization

- Fresh 2.0.0 is not yet available on deno.land/x. The latest stable version is Fresh 1.7.3, which works perfectly for this project.
- Fresh project structure requires:
  - `deno.json` with Fresh imports and tasks
  - `dev.ts` for development server
  - `main.ts` for production server
  - `fresh.config.ts` for configuration
  - `fresh.gen.ts` for route manifest (auto-generated)
  - `routes/` directory for page routes
  - `static/` directory for static assets
- The dev server starts on localhost:8000 by default
- Fresh uses Preact for components and supports TypeScript out of the box
- The `deno task start` command runs the development server with hot reload

## Database Configuration

- PostgreSQL client library: Use `deno.land/x/postgres@v0.17.0` for PostgreSQL connections in Deno
- Connection pooling: The postgres library provides a Pool class that handles connection pooling automatically
- Environment variables: Access via `Deno.env.get()` - no need for dotenv library in Deno
- Database module location: Created `lib/db.ts` for database utilities following common project structure
- Type safety: Use generic types with `query<T>()` for type-safe query results
- Error handling: Always check if errors are instances of Error before accessing `.message` property
- Connection pool: Singleton pattern used for pool instance to ensure single pool per application
- Test script: Created `scripts/test-db.ts` for verifying database connectivity and pooling

## Database Migrations

- Migration directory: Created `migrations/` directory for SQL migration files
- Migration naming: Use numbered prefix (001_, 002_, etc.) for execution order
- Migration runner: Created `scripts/migrate.ts` for running migrations with tracking
- Migration tracking: Uses `migrations` table to track executed migrations and prevent duplicates
- Migration execution: Migrations run in transactions with rollback on failure
- File operations: Use Deno built-in APIs (`Deno.readDir`, `Deno.readTextFile`) instead of std library for file operations
- Migration tasks: Added `deno task migrate` for running migrations, `deno task test:users` for testing users table
- Users table: Includes id (UUID), email (unique), display_name, avatar_url, preferences (JSONB), created_at, updated_at with automatic timestamp triggers
- Content table: Uses PostgreSQL enum type (content_type) for type safety with values: movie, tv, documentary
- Content table structure: Includes tmdb_id (unique integer), type (enum), title, overview, release_date, poster_path, backdrop_path, metadata (JSONB), and timestamps
- Enum types: Created using `CREATE TYPE` syntax before table creation, referenced in column definition as `content_type NOT NULL`
- Test scripts: Follow consistent pattern - verify structure, test inserts, test retrievals, test queries. Created `scripts/test-content-table.ts` and added `deno task test:content`
- User_content table: Junction table for many-to-many relationship between users and content with status tracking
- User_content status enum: Created `user_content_status` enum with values: watched, to_watch, favourite
- Foreign key constraints: Use `REFERENCES table(column) ON DELETE CASCADE` for automatic cleanup when parent records are deleted
- Unique constraints: Use `UNIQUE(column1, column2)` syntax for composite unique constraints on junction tables
- Rating column: Use `NUMERIC(3, 1)` for ratings with CHECK constraint to enforce 0-10 range
- Cascade delete testing: Test cascade behaviour by deleting parent records and verifying child records are automatically deleted
- Junction table indexes: Create indexes on foreign key columns and commonly queried columns (status, watched_at) for performance
- Lists tables: Created lists table for user collections and list_items junction table for many-to-many relationship with content
- Lists table structure: Includes user_id (FK to users), name, description, is_public (boolean), and timestamps with cascade delete from users
- List_items table structure: Includes list_id (FK to lists), content_id (FK to content), position (integer for ordering), with cascade delete from both parent tables
- List ordering: Use integer position column with index on (list_id, position) for efficient ordered queries
- Composite unique constraint: Use UNIQUE(list_id, content_id) to prevent duplicate content in the same list
- Test script pattern: Follow consistent structure - verify table structure, test inserts, test ordering, test constraints, test cascade deletes

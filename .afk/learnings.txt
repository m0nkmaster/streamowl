# Project Learnings

## Fresh Framework Initialization

- Fresh 2.0.0 is not yet available on deno.land/x. The latest stable version is Fresh 1.7.3, which works perfectly for this project.
- Fresh project structure requires:
  - `deno.json` with Fresh imports and tasks
  - `dev.ts` for development server
  - `main.ts` for production server
  - `fresh.config.ts` for configuration
  - `fresh.gen.ts` for route manifest (auto-generated)
  - `routes/` directory for page routes
  - `static/` directory for static assets
- The dev server starts on localhost:8000 by default
- Fresh uses Preact for components and supports TypeScript out of the box
- The `deno task start` command runs the development server with hot reload

## Database Configuration

- PostgreSQL client library: Use `deno.land/x/postgres@v0.17.0` for PostgreSQL connections in Deno
- Connection pooling: The postgres library provides a Pool class that handles connection pooling automatically
- Environment variables: Access via `Deno.env.get()` - no need for dotenv library in Deno
- Database module location: Created `lib/db.ts` for database utilities following common project structure
- Type safety: Use generic types with `query<T>()` for type-safe query results
- Error handling: Always check if errors are instances of Error before accessing `.message` property
- Connection pool: Singleton pattern used for pool instance to ensure single pool per application
- Test script: Created `scripts/test-db.ts` for verifying database connectivity and pooling

## Database Migrations

- Migration directory: Created `migrations/` directory for SQL migration files
- Migration naming: Use numbered prefix (001_, 002_, etc.) for execution order
- Migration runner: Created `scripts/migrate.ts` for running migrations with tracking
- Migration tracking: Uses `migrations` table to track executed migrations and prevent duplicates
- Migration execution: Migrations run in transactions with rollback on failure
- File operations: Use Deno built-in APIs (`Deno.readDir`, `Deno.readTextFile`) instead of std library for file operations
- Migration tasks: Added `deno task migrate` for running migrations, `deno task test:users` for testing users table
- Users table: Includes id (UUID), email (unique), display_name, avatar_url, preferences (JSONB), created_at, updated_at with automatic timestamp triggers
- Content table: Uses PostgreSQL enum type (content_type) for type safety with values: movie, tv, documentary
- Content table structure: Includes tmdb_id (unique integer), type (enum), title, overview, release_date, poster_path, backdrop_path, metadata (JSONB), and timestamps
- Enum types: Created using `CREATE TYPE` syntax before table creation, referenced in column definition as `content_type NOT NULL`
- Test scripts: Follow consistent pattern - verify structure, test inserts, test retrievals, test queries. Created `scripts/test-content-table.ts` and added `deno task test:content`
- User_content table: Junction table for many-to-many relationship between users and content with status tracking
- User_content status enum: Created `user_content_status` enum with values: watched, to_watch, favourite
- Foreign key constraints: Use `REFERENCES table(column) ON DELETE CASCADE` for automatic cleanup when parent records are deleted
- Unique constraints: Use `UNIQUE(column1, column2)` syntax for composite unique constraints on junction tables
- Rating column: Use `NUMERIC(3, 1)` for ratings with CHECK constraint to enforce 0-10 range
- Cascade delete testing: Test cascade behaviour by deleting parent records and verifying child records are automatically deleted
- Junction table indexes: Create indexes on foreign key columns and commonly queried columns (status, watched_at) for performance
- Lists tables: Created lists table for user collections and list_items junction table for many-to-many relationship with content
- Lists table structure: Includes user_id (FK to users), name, description, is_public (boolean), and timestamps with cascade delete from users
- List_items table structure: Includes list_id (FK to lists), content_id (FK to content), position (integer for ordering), with cascade delete from both parent tables
- List ordering: Use integer position column with index on (list_id, position) for efficient ordered queries
- Composite unique constraint: Use UNIQUE(list_id, content_id) to prevent duplicate content in the same list
- Test script pattern: Follow consistent structure - verify table structure, test inserts, test ordering, test constraints, test cascade deletes
- Tags tables: Created tags table for user-defined tags and content_tags junction table for many-to-many relationship with content
- Tags table structure: Includes user_id (FK to users), name, colour (VARCHAR(7) for hex colour codes), and timestamps with cascade delete from users
- Tags unique constraint: Use UNIQUE(user_id, name) to prevent duplicate tag names per user (allows same tag name for different users)
- Content_tags table structure: Includes tag_id (FK to tags), content_id (FK to content), with cascade delete from both parent tables
- Content_tags unique constraint: Use UNIQUE(tag_id, content_id) to prevent duplicate tag applications to the same content
- Tag colour default: Use VARCHAR(7) for hex colour codes (e.g., #3B82F6) with default value for consistent styling
- Multiple tags on content: Test applying multiple tags to a single content item to verify many-to-many relationship works correctly
- Streaming services tables: Created streaming_services table for service metadata and content_streaming junction table for availability tracking
- Streaming services table structure: Includes name (unique), logo_url, deep_link_template for generating deep links to streaming apps
- Content_streaming table structure: Includes service_id (FK to streaming_services), content_id (FK to content), region (VARCHAR(10)), type (enum: subscription/rent/buy), price (NUMERIC), available_from/until dates, with cascade delete from both parent tables
- Streaming type enum: Created streaming_type enum with values: subscription, rent, buy for categorising availability types
- Composite unique constraint: Use UNIQUE(service_id, content_id, region, type) to prevent duplicate availability entries for the same service/content/region/type combination
- Region-based availability: Store region as VARCHAR(10) to support ISO country codes (US, GB, CA, AU, DE, FR, etc.) for region-specific streaming availability
- Service seeding: Seed common streaming services (Netflix, Disney+, Amazon Prime Video, Apple TV+, HBO Max, Hulu, Paramount+, Peacock, BBC iPlayer, ITV Hub) in migration using ON CONFLICT DO NOTHING to allow re-running migrations
- Deep link templates: Store template strings in streaming_services.deep_link_template for generating deep links to content on streaming platforms
- Availability dates: Include available_from and available_until DATE columns for tracking time-limited availability (e.g., content leaving soon)

## Authentication & Session Management

- JWT library: Use `deno.land/x/djwt@v3.0.2` for JWT signing and verification in Deno
- JWT secret: Store JWT_SECRET in environment variables, use crypto.subtle.importKey for HMAC-SHA256 key generation
- Session token structure: Include userId, email, iat (issued at), and exp (expiration) in JWT payload
- Token expiration: Default to 7 days (604800 seconds) for session tokens
- Cookie security: Use HttpOnly flag to prevent JavaScript access (XSS protection), SameSite=Lax for CSRF protection, Secure flag in production
- Cookie management: Set cookies via Set-Cookie header, read from Cookie header, clear by setting Max-Age=0
- Session middleware: Extract token from cookies, verify JWT, attach session to handler context state
- Token verification: Verify token signature and expiration, reject invalid or expired tokens with clear error messages
- Type safety: Use interface for SessionPayload, validate payload structure after verification to ensure type safety

## User Authentication - Email/Password Signup

- Password hashing: Use `deno.land/x/bcrypt@v0.4.1` for password hashing in Deno
- Password storage: Store bcrypt hash in `password_hash` column (VARCHAR(255)) in users table
- Password validation: Enforce minimum 8 characters on both client (HTML minLength) and server side
- Email validation: Validate email format using regex pattern on server side, normalise to lowercase before storage
- User creation: Use database transaction to ensure atomic user creation with password hash
- Duplicate email check: Query existing users before attempting insert to prevent duplicate email registration
- API routes in Fresh: Create API handlers by exporting a `handler` object with HTTP method handlers (GET, POST, etc.) from routes in `routes/api/` directory
- Form handling: Use FormData API to extract form values from POST requests in Fresh handlers
- Redirect after POST: Use 303 See Other status code with Location header for redirect after successful POST (prevents resubmission on refresh)
- Session creation: Create JWT session token immediately after user creation and set secure cookie before redirecting

## User Authentication - Email/Password Login

- Login page: Create login page at `routes/login.tsx` with form matching signup page structure
- Login API handler: Create handler at `routes/api/login.ts` following same pattern as signup handler
- Password verification: Use `verifyPassword()` function from `lib/auth/password.ts` to compare submitted password with stored bcrypt hash
- User lookup: Query users table by email (normalised to lowercase) to find existing user
- Authentication errors: Return generic "Invalid email or password" message for both non-existent users and incorrect passwords (prevents user enumeration)
- Error status codes: Use 401 Unauthorized for authentication failures, 400 for validation errors
- Session creation on login: Create JWT session token and set cookie after successful password verification, same as signup flow

## Route Protection & Authentication

- Protected routes in Fresh: Export a `handler` object with GET/POST/etc methods from route files to add middleware logic
- Route protection pattern: Check session in handler, redirect to login with return URL if unauthenticated, render page if authenticated
- Return URL handling: Preserve original destination in `returnTo` query parameter, validate to prevent open redirects (must start with "/")
- Login redirect flow: Extract `returnTo` from form data after login, default to "/dashboard" if not provided, redirect user back to original destination
- API route protection: Use `requireAuthForApi()` helper function to check authentication and return 401 JSON response for unauthenticated requests
- Redirect status codes: Use 302 Found for redirects to login page, 303 See Other for redirects after POST requests
- Session checking: Use `getSessionFromRequest()` from middleware to extract and validate session token in route handlers

## TMDB API Integration

- TMDB API client: Created `lib/tmdb/client.ts` for TMDB API interactions with rate limiting and error handling
- API key configuration: Store TMDB_API_KEY in environment variables, accessed via `Deno.env.get()`
- Rate limiting: Implemented sliding window rate limiter to enforce 50 requests per second limit (TMDB free tier limit)
- Rate limiter pattern: Use singleton RateLimiter class with request timestamp tracking, automatically waits when limit reached
- TMDB API base URL: Use `https://api.themoviedb.org/3` as base URL for all API requests
- API error handling: TMDB returns JSON with `success: false` and `status_code`/`status_message` fields for errors
- Error code 34: TMDB status code 34 indicates resource not found (e.g., invalid movie ID)
- Movie details interface: Define TypeScript interface for MovieDetails with required fields (id, title, overview, release_date, poster_path, backdrop_path, vote_average, vote_count, runtime, genres)
- Request function: Generic `request<T>()` function handles rate limiting, API key injection, parameter encoding, and error parsing
- Test script pattern: Created `scripts/test-tmdb-client.ts` following same pattern as other test scripts - verify functionality, test error cases, test rate limiting
- Environment variable documentation: Added TMDB_API_KEY to `.env.example` with instructions to get API key from TMDB settings
- Movie search function: Created `searchMovies()` function in TMDB client that accepts query string and page number, returns paginated results
- TMDB search endpoint: Use `/search/movie` endpoint with `query` and `page` parameters for movie search
- Search response mapping: TMDB search returns `{ page, results[], total_pages, total_results }` structure, map results to internal Content model with type 'movie'
- Content model mapping: Map TMDB movie search results to internal Content interface with tmdb_id, type: 'movie', title, overview, release_date, poster_path, backdrop_path, and metadata object
- Pagination validation: Validate page number is positive integer, validate query is non-empty string before making API request
- Search test script: Created `scripts/test-tmdb-search.ts` to test search functionality, pagination, and error handling, added `deno task test:tmdb-search` to deno.json
- TV show search function: Created `searchTv()` function in TMDB client that accepts query string and page number, returns paginated results with type 'tv'
- TMDB TV search endpoint: Use `/search/tv` endpoint with `query` and `page` parameters for TV show search
- TV show field mapping: TMDB TV shows use `name` field instead of `title`, and `first_air_date` instead of `release_date` - map these to internal Content model fields
- TV search response mapping: TMDB TV search returns same structure as movie search but with TV-specific fields, map to Content model with type 'tv'
- TV content type verification: Test script verifies all search results have type 'tv' to ensure correct mapping

# Project Learnings

## Fresh Framework Initialization

- Fresh 2.0.0 is not yet available on deno.land/x. The latest stable version is Fresh 1.7.3, which works perfectly for this project.
- Fresh project structure requires:
  - `deno.json` with Fresh imports and tasks
  - `dev.ts` for development server
  - `main.ts` for production server
  - `fresh.config.ts` for configuration
  - `fresh.gen.ts` for route manifest (auto-generated)
  - `routes/` directory for page routes
  - `static/` directory for static assets
- The dev server starts on localhost:8000 by default
- Fresh uses Preact for components and supports TypeScript out of the box
- The `deno task start` command runs the development server with hot reload

## Database Configuration

- PostgreSQL client library: Use `deno.land/x/postgres@v0.17.0` for PostgreSQL connections in Deno
- Connection pooling: The postgres library provides a Pool class that handles connection pooling automatically
- Environment variables: Access via `Deno.env.get()` - no need for dotenv library in Deno
- Database module location: Created `lib/db.ts` for database utilities following common project structure
- Type safety: Use generic types with `query<T>()` for type-safe query results
- Error handling: Always check if errors are instances of Error before accessing `.message` property
- Connection pool: Singleton pattern used for pool instance to ensure single pool per application
- Test script: Created `scripts/test-db.ts` for verifying database connectivity and pooling

## Database Migrations

- Migration directory: Created `migrations/` directory for SQL migration files
- Migration naming: Use numbered prefix (001_, 002_, etc.) for execution order
- Migration runner: Created `scripts/migrate.ts` for running migrations with tracking
- Migration tracking: Uses `migrations` table to track executed migrations and prevent duplicates
- Migration execution: Migrations run in transactions with rollback on failure
- File operations: Use Deno built-in APIs (`Deno.readDir`, `Deno.readTextFile`) instead of std library for file operations
- Migration tasks: Added `deno task migrate` for running migrations, `deno task test:users` for testing users table
- Users table: Includes id (UUID), email (unique), display_name, avatar_url, preferences (JSONB), created_at, updated_at with automatic timestamp triggers
- Content table: Uses PostgreSQL enum type (content_type) for type safety with values: movie, tv, documentary
- Content table structure: Includes tmdb_id (unique integer), type (enum), title, overview, release_date, poster_path, backdrop_path, metadata (JSONB), and timestamps
- Enum types: Created using `CREATE TYPE` syntax before table creation, referenced in column definition as `content_type NOT NULL`
- Test scripts: Follow consistent pattern - verify structure, test inserts, test retrievals, test queries. Created `scripts/test-content-table.ts` and added `deno task test:content`
- User_content table: Junction table for many-to-many relationship between users and content with status tracking
- User_content status enum: Created `user_content_status` enum with values: watched, to_watch, favourite
- Foreign key constraints: Use `REFERENCES table(column) ON DELETE CASCADE` for automatic cleanup when parent records are deleted
- Unique constraints: Use `UNIQUE(column1, column2)` syntax for composite unique constraints on junction tables
- Rating column: Use `NUMERIC(3, 1)` for ratings with CHECK constraint to enforce 0-10 range
- Cascade delete testing: Test cascade behaviour by deleting parent records and verifying child records are automatically deleted
- Junction table indexes: Create indexes on foreign key columns and commonly queried columns (status, watched_at) for performance
- Lists tables: Created lists table for user collections and list_items junction table for many-to-many relationship with content
- Lists table structure: Includes user_id (FK to users), name, description, is_public (boolean), and timestamps with cascade delete from users
- List_items table structure: Includes list_id (FK to lists), content_id (FK to content), position (integer for ordering), with cascade delete from both parent tables
- List ordering: Use integer position column with index on (list_id, position) for efficient ordered queries
- Composite unique constraint: Use UNIQUE(list_id, content_id) to prevent duplicate content in the same list
- Test script pattern: Follow consistent structure - verify table structure, test inserts, test ordering, test constraints, test cascade deletes
- Tags tables: Created tags table for user-defined tags and content_tags junction table for many-to-many relationship with content
- Tags table structure: Includes user_id (FK to users), name, colour (VARCHAR(7) for hex colour codes), and timestamps with cascade delete from users
- Tags unique constraint: Use UNIQUE(user_id, name) to prevent duplicate tag names per user (allows same tag name for different users)
- Content_tags table structure: Includes tag_id (FK to tags), content_id (FK to content), with cascade delete from both parent tables
- Content_tags unique constraint: Use UNIQUE(tag_id, content_id) to prevent duplicate tag applications to the same content
- Tag colour default: Use VARCHAR(7) for hex colour codes (e.g., #3B82F6) with default value for consistent styling
- Multiple tags on content: Test applying multiple tags to a single content item to verify many-to-many relationship works correctly
- Streaming services tables: Created streaming_services table for service metadata and content_streaming junction table for availability tracking
- Streaming services table structure: Includes name (unique), logo_url, deep_link_template for generating deep links to streaming apps
- Content_streaming table structure: Includes service_id (FK to streaming_services), content_id (FK to content), region (VARCHAR(10)), type (enum: subscription/rent/buy), price (NUMERIC), available_from/until dates, with cascade delete from both parent tables
- Streaming type enum: Created streaming_type enum with values: subscription, rent, buy for categorising availability types
- Composite unique constraint: Use UNIQUE(service_id, content_id, region, type) to prevent duplicate availability entries for the same service/content/region/type combination
- Region-based availability: Store region as VARCHAR(10) to support ISO country codes (US, GB, CA, AU, DE, FR, etc.) for region-specific streaming availability
- Service seeding: Seed common streaming services (Netflix, Disney+, Amazon Prime Video, Apple TV+, HBO Max, Hulu, Paramount+, Peacock, BBC iPlayer, ITV Hub) in migration using ON CONFLICT DO NOTHING to allow re-running migrations
- Deep link templates: Store template strings in streaming_services.deep_link_template for generating deep links to content on streaming platforms
- Availability dates: Include available_from and available_until DATE columns for tracking time-limited availability (e.g., content leaving soon)

## Authentication & Session Management

- JWT library: Use `deno.land/x/djwt@v3.0.2` for JWT signing and verification in Deno
- JWT secret: Store JWT_SECRET in environment variables, use crypto.subtle.importKey for HMAC-SHA256 key generation
- Session token structure: Include userId, email, iat (issued at), and exp (expiration) in JWT payload
- Token expiration: Default to 7 days (604800 seconds) for session tokens
- Cookie security: Use HttpOnly flag to prevent JavaScript access (XSS protection), SameSite=Lax for CSRF protection, Secure flag in production
- Cookie management: Set cookies via Set-Cookie header, read from Cookie header, clear by setting Max-Age=0
- Session middleware: Extract token from cookies, verify JWT, attach session to handler context state
- Token verification: Verify token signature and expiration, reject invalid or expired tokens with clear error messages
- Type safety: Use interface for SessionPayload, validate payload structure after verification to ensure type safety

## User Authentication - Email/Password Signup

- Password hashing: Use `deno.land/x/bcrypt@v0.4.1` for password hashing in Deno
- Password storage: Store bcrypt hash in `password_hash` column (VARCHAR(255)) in users table
- Password validation: Enforce minimum 8 characters on both client (HTML minLength) and server side
- Email validation: Validate email format using regex pattern on server side, normalise to lowercase before storage
- User creation: Use database transaction to ensure atomic user creation with password hash
- Duplicate email check: Query existing users before attempting insert to prevent duplicate email registration
- API routes in Fresh: Create API handlers by exporting a `handler` object with HTTP method handlers (GET, POST, etc.) from routes in `routes/api/` directory
- Form handling: Use FormData API to extract form values from POST requests in Fresh handlers
- Redirect after POST: Use 303 See Other status code with Location header for redirect after successful POST (prevents resubmission on refresh)
- Session creation: Create JWT session token immediately after user creation and set secure cookie before redirecting

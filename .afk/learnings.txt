# Project Learnings

## Fresh Framework Initialization

- Fresh 2.0.0 is not yet available on deno.land/x. The latest stable version is Fresh 1.7.3, which works perfectly for this project.
- Fresh project structure requires:
  - `deno.json` with Fresh imports and tasks
  - `dev.ts` for development server
  - `main.ts` for production server
  - `fresh.config.ts` for configuration
  - `fresh.gen.ts` for route manifest (auto-generated)
  - `routes/` directory for page routes
  - `static/` directory for static assets
- The dev server starts on localhost:8000 by default
- Fresh uses Preact for components and supports TypeScript out of the box
- The `deno task start` command runs the development server with hot reload

## Database Configuration

- PostgreSQL client library: Use `deno.land/x/postgres@v0.17.0` for PostgreSQL connections in Deno
- Connection pooling: The postgres library provides a Pool class that handles connection pooling automatically
- Environment variables: Access via `Deno.env.get()` - no need for dotenv library in Deno
- Database module location: Created `lib/db.ts` for database utilities following common project structure
- Type safety: Use generic types with `query<T>()` for type-safe query results
- Error handling: Always check if errors are instances of Error before accessing `.message` property
- Connection pool: Singleton pattern used for pool instance to ensure single pool per application
- Test script: Created `scripts/test-db.ts` for verifying database connectivity and pooling

## Database Migrations

- Migration directory: Created `migrations/` directory for SQL migration files
- Migration naming: Use numbered prefix (001_, 002_, etc.) for execution order
- Migration runner: Created `scripts/migrate.ts` for running migrations with tracking
- Migration tracking: Uses `migrations` table to track executed migrations and prevent duplicates
- Migration execution: Migrations run in transactions with rollback on failure
- File operations: Use Deno built-in APIs (`Deno.readDir`, `Deno.readTextFile`) instead of std library for file operations
- Migration tasks: Added `deno task migrate` for running migrations, `deno task test:users` for testing users table
- Migration rollback support: Added up/down migration support using `-- down` marker to separate up and down SQL sections in migration files
- Rollback functionality: Implemented `rollbackMigration()` function to execute down migrations and remove migration from tracking table
- Rollback commands: Added `deno task migrate:rollback` to rollback last migration, or `deno task migrate:rollback <name>` to rollback specific migration
- Migration parsing: Migration files can contain both up and down sections separated by `-- down` marker, or just up section (backward compatible with existing migrations)
- Rollback validation: Rollback fails if migration doesn't have a down section, preventing partial rollbacks
- Users table: Includes id (UUID), email (unique), display_name, avatar_url, preferences (JSONB), created_at, updated_at with automatic timestamp triggers
- Content table: Uses PostgreSQL enum type (content_type) for type safety with values: movie, tv, documentary
- Content table structure: Includes tmdb_id (unique integer), type (enum), title, overview, release_date, poster_path, backdrop_path, metadata (JSONB), and timestamps
- Enum types: Created using `CREATE TYPE` syntax before table creation, referenced in column definition as `content_type NOT NULL`
- Test scripts: Follow consistent pattern - verify structure, test inserts, test retrievals, test queries. Created `scripts/test-content-table.ts` and added `deno task test:content`
- User_content table: Junction table for many-to-many relationship between users and content with status tracking
- User_content status enum: Created `user_content_status` enum with values: watched, to_watch, favourite
- Foreign key constraints: Use `REFERENCES table(column) ON DELETE CASCADE` for automatic cleanup when parent records are deleted
- Unique constraints: Use `UNIQUE(column1, column2)` syntax for composite unique constraints on junction tables
- Rating column: Use `NUMERIC(3, 1)` for ratings with CHECK constraint to enforce 0-10 range
- Cascade delete testing: Test cascade behaviour by deleting parent records and verifying child records are automatically deleted
- Junction table indexes: Create indexes on foreign key columns and commonly queried columns (status, watched_at) for performance
- Lists tables: Created lists table for user collections and list_items junction table for many-to-many relationship with content
- Lists table structure: Includes user_id (FK to users), name, description, is_public (boolean), and timestamps with cascade delete from users
- List_items table structure: Includes list_id (FK to lists), content_id (FK to content), position (integer for ordering), with cascade delete from both parent tables
- List ordering: Use integer position column with index on (list_id, position) for efficient ordered queries
- Composite unique constraint: Use UNIQUE(list_id, content_id) to prevent duplicate content in the same list
- Test script pattern: Follow consistent structure - verify table structure, test inserts, test ordering, test constraints, test cascade deletes
- Tags tables: Created tags table for user-defined tags and content_tags junction table for many-to-many relationship with content
- Tags table structure: Includes user_id (FK to users), name, colour (VARCHAR(7) for hex colour codes), and timestamps with cascade delete from users
- Tags unique constraint: Use UNIQUE(user_id, name) to prevent duplicate tag names per user (allows same tag name for different users)
- Content_tags table structure: Includes tag_id (FK to tags), content_id (FK to content), with cascade delete from both parent tables
- Content_tags unique constraint: Use UNIQUE(tag_id, content_id) to prevent duplicate tag applications to the same content
- Tag colour default: Use VARCHAR(7) for hex colour codes (e.g., #3B82F6) with default value for consistent styling
- Multiple tags on content: Test applying multiple tags to a single content item to verify many-to-many relationship works correctly
- Streaming services tables: Created streaming_services table for service metadata and content_streaming junction table for availability tracking
- Streaming services table structure: Includes name (unique), logo_url, deep_link_template for generating deep links to streaming apps
- Content_streaming table structure: Includes service_id (FK to streaming_services), content_id (FK to content), region (VARCHAR(10)), type (enum: subscription/rent/buy), price (NUMERIC), available_from/until dates, with cascade delete from both parent tables
- Streaming type enum: Created streaming_type enum with values: subscription, rent, buy for categorising availability types
- Composite unique constraint: Use UNIQUE(service_id, content_id, region, type) to prevent duplicate availability entries for the same service/content/region/type combination
- Region-based availability: Store region as VARCHAR(10) to support ISO country codes (US, GB, CA, AU, DE, FR, etc.) for region-specific streaming availability
- Service seeding: Seed common streaming services (Netflix, Disney+, Amazon Prime Video, Apple TV+, HBO Max, Hulu, Paramount+, Peacock, BBC iPlayer, ITV Hub) in migration using ON CONFLICT DO NOTHING to allow re-running migrations
- Deep link templates: Store template strings in streaming_services.deep_link_template for generating deep links to content on streaming platforms
- Availability dates: Include available_from and available_until DATE columns for tracking time-limited availability (e.g., content leaving soon)

## Authentication & Session Management

- JWT library: Use `deno.land/x/djwt@v3.0.2` for JWT signing and verification in Deno
- JWT secret: Store JWT_SECRET in environment variables, use crypto.subtle.importKey for HMAC-SHA256 key generation
- Session token structure: Include userId, email, iat (issued at), and exp (expiration) in JWT payload
- Token expiration: Default to 7 days (604800 seconds) for session tokens
- Cookie security: Use HttpOnly flag to prevent JavaScript access (XSS protection), SameSite=Lax for CSRF protection, Secure flag in production
- Cookie management: Set cookies via Set-Cookie header, read from Cookie header, clear by setting Max-Age=0
- Session middleware: Extract token from cookies, verify JWT, attach session to handler context state
- Token verification: Verify token signature and expiration, reject invalid or expired tokens with clear error messages
- Type safety: Use interface for SessionPayload, validate payload structure after verification to ensure type safety

## User Authentication - Email/Password Signup

- Password hashing: Use `deno.land/x/bcrypt@v0.4.1` for password hashing in Deno
- Password storage: Store bcrypt hash in `password_hash` column (VARCHAR(255)) in users table
- Password validation: Enforce minimum 8 characters on both client (HTML minLength) and server side
- Email validation: Validate email format using regex pattern on server side, normalise to lowercase before storage
- User creation: Use database transaction to ensure atomic user creation with password hash
- Duplicate email check: Query existing users before attempting insert to prevent duplicate email registration
- API routes in Fresh: Create API handlers by exporting a `handler` object with HTTP method handlers (GET, POST, etc.) from routes in `routes/api/` directory
- Form handling: Use FormData API to extract form values from POST requests in Fresh handlers
- Redirect after POST: Use 303 See Other status code with Location header for redirect after successful POST (prevents resubmission on refresh)
- Session creation: Create JWT session token immediately after user creation and set secure cookie before redirecting

## User Authentication - Email/Password Login

- Login page: Create login page at `routes/login.tsx` with form matching signup page structure
- Login API handler: Create handler at `routes/api/login.ts` following same pattern as signup handler
- Password verification: Use `verifyPassword()` function from `lib/auth/password.ts` to compare submitted password with stored bcrypt hash
- Bcrypt hash format: Bcrypt hashes start with `$2a$`, `$2b$`, or `$2y$` followed by cost factor and are typically 60 characters long
- Password hashing test script: Created `scripts/test-password-hashing.ts` to verify passwords are hashed before storage, stored as bcrypt format (not plaintext), and login works with correct/incorrect passwords, added `deno task test:password-hashing` to deno.json
- User lookup: Query users table by email (normalised to lowercase) to find existing user
- Authentication errors: Return generic "Invalid email or password" message for both non-existent users and incorrect passwords (prevents user enumeration)
- Error status codes: Use 401 Unauthorized for authentication failures, 400 for validation errors
- Session creation on login: Create JWT session token and set cookie after successful password verification, same as signup flow

## Route Protection & Authentication

- Protected routes in Fresh: Export a `handler` object with GET/POST/etc methods from route files to add middleware logic
- Route protection pattern: Check session in handler, redirect to login with return URL if unauthenticated, render page if authenticated
- Return URL handling: Preserve original destination in `returnTo` query parameter, validate to prevent open redirects (must start with "/")
- Login redirect flow: Extract `returnTo` from form data after login, default to "/dashboard" if not provided, redirect user back to original destination
- API route protection: Use `requireAuthForApi()` helper function to check authentication and return 401 JSON response for unauthenticated requests
- Redirect status codes: Use 302 Found for redirects to login page, 303 See Other for redirects after POST requests
- Session checking: Use `getSessionFromRequest()` from middleware to extract and validate session token in route handlers

## TMDB API Integration

- TMDB API client: Created `lib/tmdb/client.ts` for TMDB API interactions with rate limiting and error handling
- API key configuration: Store TMDB_API_KEY in environment variables, accessed via `Deno.env.get()`
- Rate limiting: Implemented sliding window rate limiter to enforce 50 requests per second limit (TMDB free tier limit)
- Rate limiter pattern: Use singleton RateLimiter class with request timestamp tracking, automatically waits when limit reached
- TMDB API base URL: Use `https://api.themoviedb.org/3` as base URL for all API requests
- API error handling: TMDB returns JSON with `success: false` and `status_code`/`status_message` fields for errors
- Error code 34: TMDB status code 34 indicates resource not found (e.g., invalid movie ID)
- Movie details interface: Define TypeScript interface for MovieDetails with required fields (id, title, overview, release_date, poster_path, backdrop_path, vote_average, vote_count, runtime, genres)
- Request function: Generic `request<T>()` function handles rate limiting, API key injection, parameter encoding, and error parsing
- Test script pattern: Created `scripts/test-tmdb-client.ts` following same pattern as other test scripts - verify functionality, test error cases, test rate limiting
- Environment variable documentation: Added TMDB_API_KEY to `.env.example` with instructions to get API key from TMDB settings
- Movie search function: Created `searchMovies()` function in TMDB client that accepts query string and page number, returns paginated results
- TMDB search endpoint: Use `/search/movie` endpoint with `query` and `page` parameters for movie search
- Search response mapping: TMDB search returns `{ page, results[], total_pages, total_results }` structure, map results to internal Content model with type 'movie'
- Content model mapping: Map TMDB movie search results to internal Content interface with tmdb_id, type: 'movie', title, overview, release_date, poster_path, backdrop_path, and metadata object
- Pagination validation: Validate page number is positive integer, validate query is non-empty string before making API request
- Search test script: Created `scripts/test-tmdb-search.ts` to test search functionality, pagination, and error handling, added `deno task test:tmdb-search` to deno.json
- TV show search function: Created `searchTv()` function in TMDB client that accepts query string and page number, returns paginated results with type 'tv'
- TMDB TV search endpoint: Use `/search/tv` endpoint with `query` and `page` parameters for TV show search
- TV show field mapping: TMDB TV shows use `name` field instead of `title`, and `first_air_date` instead of `release_date` - map these to internal Content model fields
- TV search response mapping: TMDB TV search returns same structure as movie search but with TV-specific fields, map to Content model with type 'tv'
- TV content type verification: Test script verifies all search results have type 'tv' to ensure correct mapping
- Content details functions: Created `getMovieDetails()` and `getTvDetails()` functions that fetch full content details including cast, crew, and images
- TMDB append_to_response parameter: Use `append_to_response=credits,images` query parameter to include credits and images in a single API request
- Credits structure: TMDB credits include `cast[]` array with cast members (name, character, profile_path) and `crew[]` array with crew members (name, job, department, profile_path)
- Images structure: TMDB images include `posters[]` array and `backdrops[]` array, each containing image objects with file_path, width, height, aspect_ratio, vote_average, vote_count
- Cast member interface: Define CastMember interface with id, name, character, order, profile_path fields
- Crew member interface: Define CrewMember interface with id, name, job, department, profile_path fields
- Image interface: Define Image interface with file_path, width, height, aspect_ratio, vote_average, vote_count fields
- MovieDetails interface: Extended MovieDetails interface to include optional `credits?: Credits` and `images?: Images` fields
- TvDetails interface: Created TvDetails interface similar to MovieDetails but with TV-specific fields (name instead of title, first_air_date instead of release_date, episode_run_time instead of runtime)
- Content details test script: Created `scripts/test-tmdb-content-details.ts` to test fetching movie and TV details, verify credits and images are included, test error handling, added `deno task test:tmdb-content-details` to deno.json

## Security - SQL Injection Prevention

- Parameterised queries: All database queries use parameterised statements with $1, $2, etc. placeholders to prevent SQL injection attacks
- Query function security: The `query()` function in `lib/db.ts` uses `queryObject()` with separate `text` and `args` parameters, ensuring user input is never concatenated into SQL strings
- Code review verification: All queries in routes/api/ (login.ts, signup.ts) use parameterised queries with placeholders
- Test script: Created `scripts/test-sql-injection-protection.ts` to verify SQL injection payloads are safely handled as literal strings, added `deno task test:sql-injection` to deno.json
- Documentation: Added security documentation to `query()` function with examples of correct (parameterised) and incorrect (concatenated) usage patterns
- Best practice: Never concatenate user input directly into SQL strings - always use parameterised queries with placeholders

## Security - XSS Prevention

- HTML escaping utility: Created `lib/security/xss.ts` with `escapeHtml()`, `escapeHtmlAttribute()`, and `escapeJsString()` functions to sanitise user input
- HTML escaping: Escapes HTML special characters (< > & " ') to their HTML entity equivalents (&lt; &gt; &amp; &quot; &#x27;) to prevent XSS attacks
- Preact automatic escaping: Preact/React automatically escapes content in JSX, but utilities should be used when working with raw HTML strings or setting HTML attributes from user input
- Test script: Created `scripts/test-xss-prevention.ts` to verify XSS attack vectors (script tags, event handlers, JavaScript protocols) are neutralised, added `deno task test:xss` to deno.json
- XSS attack vectors tested: Script tags, event handlers (onerror, onload, onfocus), JavaScript protocol injection, iframe injection, and various HTML injection techniques
- Edge cases: Functions handle null, undefined, and empty strings gracefully by returning empty string
- Best practice: Always escape user-generated content before displaying in HTML, especially when using dangerouslySetInnerHTML or setting HTML attributes dynamically

## Authentication - Google OAuth

- OAuth flow: Implemented OAuth 2.0 authorization code flow with Google (initiation endpoint redirects to Google, callback endpoint handles response)
- OAuth configuration: Store GOOGLE_OAUTH_CLIENT_ID and GOOGLE_OAUTH_CLIENT_SECRET in environment variables
- OAuth initiation endpoint: Created `/api/auth/google` endpoint that generates Google OAuth URL with client ID, redirect URI, scopes (openid email profile), and state parameter
- OAuth callback endpoint: Created `/api/auth/google/callback` endpoint that exchanges authorization code for access token, fetches user profile, and creates/logs in user
- State parameter: Use base64-encoded JSON to store returnTo URL in state parameter for CSRF protection and redirect handling
- Redirect URI: Construct redirect URI dynamically from request origin to support different environments (localhost, staging, production)
- Token exchange: Exchange authorization code for access token using POST request to `https://oauth2.googleapis.com/token` with client credentials
- User profile fetching: Fetch user profile from `https://www.googleapis.com/oauth2/v2/userinfo` using access token to get email, name, picture
- Email verification: Verify `verified_email` field from Google profile before creating/logging in user
- User lookup: Check for existing users by google_id or email to handle both new signups and existing user logins
- User creation: Create new user with Google profile data (email, google_id, display_name, avatar_url) when user doesn't exist
- User linking: Update existing users with google_id if they sign in with Google but already have an account with that email
- Profile updates: Update display_name and avatar_url from Google profile if available and not already set
- Database migration: Added google_id column (VARCHAR(255)) to users table with index for OAuth user lookup
- UI integration: Added "Continue with Google" buttons to login and signup pages with Google logo SVG icon and divider styling
- OAuth button styling: Use Tailwind classes for consistent styling with white background, gray border, and hover states matching existing form buttons
- Error handling: Handle OAuth errors (missing code, email not verified, token exchange failures) with redirects to login page with error query parameters
- Session creation: Create JWT session token and set secure cookie after successful OAuth authentication, same as email/password flow

## Authentication - Logout

- Logout endpoint: Created `/api/logout` endpoint that clears session cookie and redirects to homepage
- Logout methods: Support both POST (form submission) and GET (link navigation) requests for logout
- Cookie clearing: Use `clearSessionCookie()` function to set session cookie with Max-Age=0, matching same security flags (HttpOnly, SameSite, Secure) as session cookie creation
- Secure flag consistency: Ensure logout cookie clearing includes Secure flag when in production environment, matching the pattern used in `setSessionCookie()`
- Logout UI: Add logout button to dashboard page with form POST to `/api/logout` endpoint
- Redirect after logout: Redirect to homepage ("/") after clearing session cookie
- Session validation: After logout, protected routes will redirect to login since session cookie is cleared

## TMDB API - Watch Providers

- Watch providers endpoints: Use `/movie/{movie_id}/watch/providers` and `/tv/{tv_id}/watch/providers` endpoints to fetch streaming availability data
- Watch providers response structure: TMDB returns a `results` object where keys are ISO 3166-1 country codes (e.g., "US", "GB", "CA", "AU", "DE", "FR"), and each country has `flatrate` (subscription), `rent`, `buy`, `ads`, and `free` arrays
- Provider structure: Each provider includes `provider_id`, `provider_name`, `logo_path`, `display_priority`, and other metadata fields
- Region filtering: Created `filterWatchProvidersByRegion()` function to extract and categorise providers for a specific region from the full response
- Supported regions: Defined `SUPPORTED_REGIONS` constant array with ["US", "GB", "CA", "AU", "DE", "FR"] for type-safe region handling
- Categorisation: Providers are categorised into `subscription` (flatrate), `rent`, `buy`, `ads`, and `free` arrays for easy consumption
- Convenience functions: Created `getMovieWatchProvidersByRegion()` and `getTvWatchProvidersByRegion()` functions that combine fetching and filtering in a single call
- Null handling: Functions return `null` if no providers are available for the specified region (not an error condition)
- Type safety: Created TypeScript interfaces (`WatchProvider`, `RegionWatchProviders`, `WatchProvidersResponse`, `CategorisedWatchProviders`) for type-safe handling of watch provider data

## TMDB API - Redis Caching Layer

- Redis cache module: Created `lib/cache/redis.ts` for Redis/Upstash caching of TMDB API responses to reduce API calls and improve performance
- Upstash REST API: Use Upstash Redis REST API with POST requests containing Redis command arrays (e.g., ["GET", key], ["SETEX", key, ttl, value], ["DEL", key])
- Cache configuration: Store UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN in environment variables, cache gracefully degrades if not configured
- Cache key generation: Generate cache keys from endpoint and sorted parameters (e.g., "tmdb:/movie/550:append_to_response=credits,images") for consistent key generation
- Cache entry structure: Store cache entries as JSON objects with `{ data: T, expiresAt: number }` to track expiration times
- Cache TTL: Default cache TTL is 24 hours (86400 seconds) for TMDB API responses, configurable per request
- Cache integration: Integrated cache wrapper into TMDB client `request()` function - checks cache first, falls back to API if cache miss, stores successful responses
- Graceful degradation: Cache failures (Redis unavailable, network errors) are logged as warnings but don't break API functionality - app continues without cache
- Cache expiry handling: Cache entries include expiration timestamp, expired entries are automatically deleted when accessed
- Error caching: Don't cache API errors (only cache successful responses) to allow retry of transient failures
- Cache test script: Created `scripts/test-tmdb-cache.ts` to test cache hits, cache expiry, and graceful degradation, added `deno task test:tmdb-cache` to deno.json
- Singleton pattern: Use singleton RedisCache instance for consistent cache access across the application

## Search Page Implementation

- Search API endpoint: Created `/api/search` endpoint that combines movie and TV search results from TMDB API, searches both in parallel using Promise.all for performance
- Search route: Created `/routes/search.tsx` page route that renders search page with island component for client-side interactivity
- Fresh islands: Created `/islands/SearchPage.tsx` island component for client-side search functionality with debouncing and instant results display
- Island components: Fresh islands are client-side interactive components placed in `islands/` directory, automatically hydrated on the client side
- Debounced search: Implemented 300ms debounce delay using setTimeout in useEffect hook to prevent excessive API calls while user types
- Search state management: Use Preact hooks (useState, useEffect) for managing search query, results, loading, and error states
- Result display: Display search results in responsive grid layout (2-5 columns based on viewport) with poster images, titles, content type badges, and release years
- Poster image URLs: Construct TMDB poster image URLs using `https://image.tmdb.org/t/p/w300${poster_path}` format, fallback to placeholder if no poster
- Content type badges: Display content type (movie/tv) as uppercase badge on result cards to distinguish between movies and TV shows
- Loading states: Show "Searching..." message while API request is in progress, clear results when query is empty
- Error handling: Display error messages if search fails, gracefully handle API errors without breaking the UI
- Empty states: Show helpful messages when no query entered ("Start typing to search...") or no results found ("No results found for...")
- Result links: Each result card links to `/content/{tmdb_id}` detail page (to be implemented in future story)
- API response caching: Search API endpoint includes Cache-Control header (1 hour) for HTTP caching of search results
- Type safety: Use TypeScript interfaces (SearchResponse, Content) for type-safe handling of search data throughout the component
- Combined search results sorting: When combining movie and TV search results, sort by relevance using vote_average (descending) as primary sort key, then vote_count (descending) as tiebreaker to maintain relevance ordering across content types
- Relevance sorting: TMDB search results are already sorted by relevance within each category (movies/TV), but when combining results from separate API calls, explicit sorting is needed to maintain relevance across the unified results
- Vote metadata access: Access vote_average and vote_count from Content.metadata object (stored as metadata.vote_average and metadata.vote_count) for sorting and filtering operations

## Content Detail Page Implementation

- Dynamic routes in Fresh: Create dynamic routes using square brackets in filename (e.g., `routes/content/[tmdb_id].tsx`) to handle URL parameters
- Route parameter access: Access route parameters from `ctx.params` in Fresh route handlers (e.g., `ctx.params.tmdb_id`)
- Content type detection: When TMDB ID could be either movie or TV show, try fetching as movie first, then fall back to TV show if movie fetch fails (TMDB IDs are unique across content types)
- Movie vs TV details: Movies use `title` and `release_date` fields, TV shows use `name` and `first_air_date` fields - handle both cases in detail page component
- TV runtime format: TV shows have `episode_run_time` as an array of episode lengths (in minutes), calculate average or use first value for display
- Image URL construction: Use TMDB image base URL `https://image.tmdb.org/t/p/{size}` with sizes: w185 (profile), w300 (poster small), w500 (poster large), w1280 (backdrop)
- Backdrop display: Display backdrop image as full-width header with overlay for better visual impact
- Cast display: Show top 12 cast members with profile photos, names, and character names in responsive grid layout
- Genre badges: Display genres as coloured badges (using Tailwind classes) for visual categorisation
- Date formatting: Use `toLocaleDateString()` with locale "en-GB" for British English date formatting (e.g., "15 January 2024")
- Rating display: Format vote_average to 1 decimal place and include vote_count with locale formatting for readability
- Error handling: Return 404 status if content not found (both movie and TV fetch fail), return 400 for invalid content ID format
- Type safety: Use TypeScript type guards and type assertions to safely handle MovieDetails vs TvDetails types in component
- Watch providers fetching: Fetch watch providers in route handler using `getMovieWatchProvidersByRegion()` or `getTvWatchProvidersByRegion()` functions, defaulting to "US" region for now
- Watch providers display: Display providers grouped by availability type (Stream/Rent/Buy/Free) with service logos and links to TMDB's watch page
- Provider logo URLs: Use TMDB image base URL with w45 size for provider logos (`https://image.tmdb.org/t/p/w45${logo_path}`)
- Watch provider links: Use TMDB's `link` field from `CategorisedWatchProviders` which provides a deep link to TMDB's page for watching content in that region
- Graceful degradation: Handle watch provider fetch failures gracefully - log error but don't fail the page if providers are unavailable
- Provider categorisation: TMDB categorises providers into subscription (flatrate), rent, buy, ads, and free arrays - display each category separately for clarity

## Region Detection Implementation

- Region detection utility: Created `lib/region.ts` module with functions to detect user region from Accept-Language header, parse language codes, and map to supported regions (US, GB, CA, AU, DE, FR)
- Accept-Language parsing: Parse Accept-Language header format ("en-GB,en-US;q=0.9") by splitting on commas, extracting language codes before semicolons, and matching against language-to-region mapping
- Language-to-region mapping: Map language codes to regions (en-GB -> GB, en-US -> US, en-CA -> CA, en-AU -> AU, de/de-DE -> DE, fr/fr-FR -> FR) with fallback to default region (US) if no match found
- Region detection from request: Created `detectRegionFromRequest()` function that extracts Accept-Language header and calls detection function, can be extended for IP geolocation or user preferences in future
- Region display utilities: Created `getRegionName()` function to convert region codes to human-readable names (GB -> "United Kingdom") and `isSupportedRegion()` type guard for validation
- Content detail page integration: Updated content detail page handler to detect region from request headers and use detected region when fetching watch providers instead of hardcoded "US"
- Region indicator UI: Added region badge next to "Where to Watch" heading showing detected region code (e.g., "GB") with tooltip showing full region name for user clarity
- Default region fallback: If Accept-Language header is missing or no match found, default to "US" region to ensure watch providers always display
- Region prop passing: Added region to ContentDetailPageProps interface and pass through to component for display in UI

## Library - Watched List Implementation

- Content helper module: Created `lib/content.ts` with functions to get or create content records from TMDB data, ensuring content exists in database before creating user_content relationships
- Get or create pattern: Use `getOrCreateContent()` function that checks for existing content by TMDB ID, creates new record if not found, returns database UUID for user_content relationships
- Content creation from TMDB: When marking content as watched, fetch full TMDB details and create content record with title, overview, release_date, poster_path, backdrop_path, and metadata (vote_average, vote_count)
- User content status API: Created `/api/content/[tmdb_id]/status` endpoint to fetch user's status for specific content (watched, to_watch, favourite, or null) for initialising UI state
- Mark as watched API: Created `/api/content/[tmdb_id]/watched` endpoint with POST (mark as watched) and DELETE (remove watched status) methods, handles upsert logic (insert or update existing user_content record)
- Watched timestamp: Set `watched_at` timestamp automatically when marking content as watched, use current timestamp for both new inserts and updates
- Watched content API: Created `/api/library/watched` endpoint to fetch all watched content for authenticated user, includes content details (tmdb_id, type, title, poster_path, release_date) and watched_at timestamp
- Library tabs component: Created `islands/LibraryTabs.tsx` island component for tabbed library view with Watched, To Watch, and Favourites tabs, fetches watched content on mount when Watched tab is active
- Mark as watched button: Created `islands/MarkAsWatchedButton.tsx` island component with optimistic UI updates, toggles between "Mark as Watched" and "✓ Watched" states, handles API errors with revert on failure
- Optimistic updates: Update UI state immediately when user clicks button, revert if API call fails to maintain consistency between UI and server state
- Button visibility: Only show "Mark as Watched" button for authenticated users on content detail page, check session in route handler and pass isAuthenticated prop to component
- Library page integration: Updated `/routes/library.tsx` to use LibraryTabs island component, displays watched content in responsive grid layout with poster images, titles, and watched dates
- Date formatting: Format watched_at timestamps using `toLocaleDateString()` with "en-GB" locale for British English date formatting (e.g., "15 January 2024")
- Empty states: Display helpful messages when no watched content exists, guide users to mark content as watched to populate their library
- Content grid layout: Use responsive grid (2-5 columns based on viewport) for displaying library content, consistent with search results page layout

## Library - To Watch List Implementation

- Watchlist API endpoint: Created `/api/content/[tmdb_id]/watchlist` endpoint with POST (add to watchlist) and DELETE (remove from watchlist) methods, follows same pattern as watched endpoint but uses 'to_watch' status
- Watchlist status: Use 'to_watch' status in user_content table to track watchlist items, no watched_at timestamp needed for watchlist items
- Add to watchlist button: Created `islands/AddToWatchlistButton.tsx` island component with optimistic UI updates, similar to MarkAsWatchedButton but with different styling (indigo colour scheme)
- Watchlist content API: Created `/api/library/watchlist` endpoint to fetch all watchlist content for authenticated user, includes content details and created_at timestamp (when added to watchlist)
- Library tabs watchlist: Updated `islands/LibraryTabs.tsx` to fetch and display watchlist content when "To Watch" tab is active, uses same grid layout and date formatting as watched tab
- Tab-based data fetching: Use useEffect hook with activeTab dependency to fetch data only when specific tab is active, prevents unnecessary API calls
- Multiple content states: Content can have different statuses (watched, to_watch, favourite) - buttons check initialStatus prop to determine current state and update accordingly
- Button grouping: Display multiple action buttons (Mark as Watched, Add to Watchlist) side-by-side on content detail page using flex layout with gap spacing

## Library - Favourites List Implementation

- Favourites API endpoint: Created `/api/content/[tmdb_id]/favourite` endpoint with POST (add to favourites) and DELETE (remove from favourites) methods, follows same pattern as watchlist endpoint but uses 'favourite' status
- Favourites status: Use 'favourite' status in user_content table to track favourite items, no watched_at timestamp needed for favourites
- Favourite button: Created `islands/FavouriteButton.tsx` island component with optimistic UI updates, uses heart icon (filled when favourited) with red colour scheme to distinguish from other action buttons
- Favourites content API: Created `/api/library/favourites` endpoint to fetch all favourites content for authenticated user, includes content details and created_at timestamp (when added to favourites)
- Library tabs favourites: Updated `islands/LibraryTabs.tsx` to fetch and display favourites content when "Favourites" tab is active, uses same grid layout and date formatting as watched and watchlist tabs
- Heart icon implementation: Use SVG heart icon with conditional fill styling - filled (fill="currentColor") when favourited, outline (fill="none" with stroke) when not favourited
- Button accessibility: Add aria-label attributes to icon buttons for screen reader support, describing current state (e.g., "Remove from favourites" vs "Add to favourites")

## Library - Rating System Implementation

- Rating API endpoint: Created `/api/content/[tmdb_id]/rating` endpoint with POST (set rating) and DELETE (remove rating) methods, follows same pattern as watched/watchlist endpoints but updates rating field in user_content table
- Rating validation: Ratings are validated to be between 0 and 10, rounded to half-point precision (0.5 increments) using Math.round(rating * 2) / 2 before storage
- Rating storage: Ratings stored in user_content.rating column (NUMERIC(3, 1)) which supports 0-10 range with one decimal place precision, can be NULL if no rating set
- Rating component: Created `islands/RatingComponent.tsx` island component with slider input (range 1-10, step 0.5) and quick-select buttons (1-10) for easy rating selection, displays current rating and allows removal
- Rating display: Ratings displayed on content detail page below action buttons, and in library views (watched, watchlist, favourites) as star icon with rating value (e.g., "⭐ 8.5/10")
- Status API rating: Updated `/api/content/[tmdb_id]/status` endpoint to include rating field in response for initialising rating component state
- Library API ratings: Updated all library API endpoints (/api/library/watched, /api/library/watchlist, /api/library/favourites) to include rating field in response for displaying ratings in library views
- Rating upsert logic: When setting a rating, if user_content record exists, update rating field; if not, create new record with 'watched' status and rating (ensures rating can be set even if content not yet marked as watched)
- Optimistic UI updates: Rating component uses optimistic updates - immediately updates UI when rating changed, reverts if API call fails to maintain consistency

## Library - Custom Lists Implementation

- Lists API endpoint: Created `/api/lists` endpoint with POST method for creating custom lists, validates name (required, max 255 chars) and description (optional), returns created list with id, name, description, is_public, and created_at
- Lists fetching API: Created `/api/library/lists` endpoint with GET method to fetch all user's custom lists with item counts using LEFT JOIN and GROUP BY to count list_items per list
- Create list modal: Created `islands/CreateListModal.tsx` island component with form for name and description, handles form submission, loading states, and error display, closes modal and refreshes lists on success
- Library sidebar: Updated `islands/LibraryTabs.tsx` to include sidebar displaying custom lists with "Create List" button, fetches lists on mount, refreshes after list creation, shows item counts and links to list detail pages
- List detail route: Created `/routes/lists/[list_id].tsx` route for viewing individual lists, handles public/private list access control (public lists viewable by anyone, private lists only by owner), displays list items in responsive grid layout
- Shareable URLs: Lists have unique shareable URLs at `/lists/[list_id]` format using UUID from database, accessible to anyone for public lists, requires authentication and ownership for private lists
- List sidebar integration: Sidebar displays lists with name and item count, links to list detail pages, shows empty state when no lists exist, "Create List" button opens modal for creating new lists
- Add content to list API: Created `/api/lists/[list_id]/items` endpoint with POST method to add content to a list, validates list ownership, creates content record if needed, prevents duplicates (idempotent), sets position to end of list
- Add to list button: Created `islands/AddToListButton.tsx` island component with dropdown menu showing user's lists, fetches lists on mount, handles adding content to selected list with success/error feedback, shows loading states and empty state when no lists exist
- List item position: When adding content to list, position is calculated as MAX(position) + 1 to append to end of list, ensuring proper ordering for future reorder functionality

## Browse Page - Trending Content Implementation

- Trending API endpoint: Created `/api/trending` endpoint that fetches trending content from TMDB API using `/trending/all/{time_window}` endpoint, supports "day" and "week" time windows, returns paginated results
- Trending TMDB client function: Created `getTrending()` function in TMDB client that accepts timeWindow ("day" or "week") and page number, uses shorter cache TTL (1 hour) since trending content updates daily
- Trending response mapping: TMDB trending/all endpoint returns mixed results (movies and TV shows), need to check for 'name' field (TV) vs 'title' field (movie) to correctly map to internal Content model with appropriate type
- Browse page route: Created `/routes/browse.tsx` page route that renders browse page with island component for client-side interactivity
- Browse page island: Created `islands/BrowsePage.tsx` island component that fetches trending content on mount, displays in responsive grid layout matching search results pattern
- Trending section display: Display trending content in "Trending" section with section heading, loading states, error handling, and empty states following consistent UI patterns
- Content freshness: Trending content uses 1-hour cache TTL (shorter than default 24 hours) to ensure content updates periodically and doesn't become stale, matching TMDB's daily update cycle
- Time window parameter: Trending API supports time_window query parameter ("day" or "week") for flexibility, defaults to "day" for most recent trending content

## Database - pgvector Extension Setup

- pgvector extension: Enable pgvector extension using `CREATE EXTENSION IF NOT EXISTS vector;` in migration to add vector similarity search capabilities to PostgreSQL
- Vector column type: Use `vector(dimension)` type for storing embeddings, dimension must match embedding model (1536 for OpenAI text-embedding-3-small)
- Embedding columns: Add `taste_embedding vector(1536)` to users table for storing user taste profiles, and `content_embedding vector(1536)` to content table for storing content embeddings
- HNSW indexes: Create HNSW (Hierarchical Navigable Small World) indexes using `USING hnsw` for fast approximate nearest neighbour search on vector columns
- Cosine similarity: Use `vector_cosine_ops` operator class for cosine distance similarity search, which is standard for embedding similarity (1 - cosine similarity)
- Index parameters: HNSW indexes use `m` (number of connections per layer, default 16) and `ef_construction` (size of candidate set during construction, default 64) parameters for tuning index performance
- Index naming: Use descriptive index names like `idx_users_taste_embedding_cosine` and `idx_content_content_embedding_cosine` to clearly identify vector similarity indexes
- Migration pattern: Follow standard migration pattern with numbered prefix (010_) and descriptive filename, enable extension before adding columns, create indexes after columns are added

## AI - Content Embeddings Generation

- OpenAI embeddings API: Use OpenAI text-embedding-3-small model for generating 1536-dimensional embeddings, accessed via REST API at https://api.openai.com/v1/embeddings
- API key configuration: Store OPENAI_API_KEY in environment variables, accessed via Deno.env.get() for secure API key management
- Embedding generation: Create OpenAI client module with generateEmbedding() function that accepts text and returns 1536-dimensional vector array
- Content text generation: Combine title, synopsis, and genres into structured text format ("Title: ...\n\nSynopsis: ...\n\nGenres: ...") for embedding generation to capture semantic meaning
- Vector storage format: Store embeddings in pgvector as string representation '[0.1,0.2,...]' with explicit cast to vector(1536) type, postgres library handles type conversion automatically
- Embedding dimension verification: Always verify embedding dimension matches expected (1536 for text-embedding-3-small) before storing to prevent dimension mismatches
- Database update pattern: Use UPDATE query with content_embedding column and vector cast to store embeddings, can be called after content creation or asynchronously
- Convenience functions: Create helper functions like generateEmbeddingFromTmdbDetails() that extract title, overview, and genres from TMDB details and generate/store embeddings in one call
- Error handling: Handle OpenAI API errors (network failures, rate limits, invalid responses) with clear error messages, verify embedding dimension matches expected before storage
- Test script pattern: Create test scripts that verify embedding generation, dimension matching, database storage, and retrieval following consistent test patterns used in other modules

## AI - User Taste Profile Calculation

- Taste profile calculation: Calculate user taste profile as weighted average of watched content embeddings, stored in users.taste_embedding column (vector(1536))
- Weighted average algorithm: Aggregate watched content embeddings weighted by user ratings (higher ratings contribute more weight), normalise weights to sum to 1.0 for proper averaging
- Rating weighting: Use rating/10 as weight (0-1 scale), with minimum weight of 0.1 for very low ratings to ensure all content contributes, default weight of 5.0 (0.5 normalised) for unrated content
- Embedding aggregation: Calculate weighted average by multiplying each embedding vector by its normalised weight and summing across all dimensions, verify all embeddings have same dimension (1536) before aggregation
- Taste profile storage: Store calculated taste embedding in users.taste_embedding column using pgvector format '[0.1,0.2,...]' with explicit cast to vector(1536) type
- Empty state handling: Set taste_embedding to NULL when user has no watched content or no content with embeddings, allows distinguishing between users without data and users with calculated profiles
- Recalculation triggers: Recalculate taste profile automatically when user rates content or marks content as watched, call recalculateTasteProfile() after database updates in rating and watched endpoints
- Error handling: Taste profile calculation errors are logged but don't fail the main operation (non-blocking), ensures user actions (rating/watching) succeed even if taste profile calculation fails
- Content embedding requirement: Only include watched content that has content_embedding IS NOT NULL in taste profile calculation, filters out content without embeddings to prevent NULL errors
- Test coverage: Test taste profile calculation with various scenarios: multiple watched items, rating weighting, unrated content, no watched content, content without embeddings

## AI - Recommendation Candidates Generation

- Vector similarity search: Use pgvector cosine distance operator (<=>) to find content similar to user taste profile, lower distance indicates higher similarity
- Recommendation query: Query content table with taste embedding using `content_embedding <=> $1::vector(1536) AS distance` to calculate similarity, order by distance ascending for most similar first
- Watched content exclusion: Exclude already watched content using NOT IN subquery on user_content table filtering by user_id and status='watched', ensures users don't see content they've already watched
- Diversity scoring: Apply diversity penalty to avoid repetitive recommendations by limiting consecutive items of same type (max 2-3), penalising candidates too similar to recently selected items, and ensuring variety in content types
- Similarity calculation: Convert cosine distance to similarity score using `1 - distance` formula, similarity ranges from 0 (dissimilar) to 1 (identical), higher similarity scores indicate better matches
- Candidate ranking: Rank candidates by similarity score (descending), apply diversity penalties to similarity scores, select top candidates that balance similarity and diversity
- Empty state handling: Return empty array if user has no taste profile (taste_embedding IS NULL), allows graceful handling of users without sufficient watched content for recommendations
- Query optimisation: Fetch more candidates than needed (limit * 2) before diversity filtering to ensure sufficient variety after diversity scoring, then select top N diversified candidates
- Test coverage: Test recommendation generation with various scenarios: user with taste profile, user without taste profile, exclusion of watched content, diversity scoring, similarity ranking

## AI - Recommendation Explanations

- GPT-4 chat completions: Use OpenAI chat completions API with gpt-4-turbo model for generating natural language explanations, requires structured prompt with system and user messages
- Explanation prompt structure: Create system message defining assistant role and explanation style (brief, personalised, 2-3 sentences), user message includes watched content history and candidate details
- User history context: Fetch top 10 most recent watched content with ratings to provide context for personalised explanations, format as bulleted list with titles, years, and ratings
- Explanation generation: Call generateChatCompletion with structured messages array, parse response content to extract explanation text, handle API errors gracefully with fallback explanation
- Candidate details: Include candidate title, type (movie/TV show), release year, and overview in prompt to help GPT-4 generate relevant explanations
- History references: Prompt explicitly asks GPT-4 to reference specific titles from user history when relevant, improves personalisation and trust in recommendations
- Fallback handling: Return generic fallback explanation if GPT-4 API call fails, ensures recommendations always have explanations even if API is unavailable
- Interface extension: Add optional explanation field to RecommendationCandidate interface, allows explanations to be attached to candidates without breaking existing code

## AI - Recommendation Daily Feed Implementation

- Daily recommendation API endpoint: Created `/api/recommendations` endpoint that requires authentication, generates up to 3 recommendations for free tier users, and includes explanations for each recommendation
- Daily caching strategy: Use Redis cache with daily cache keys (`recommendations:${userId}:${date}`) to ensure recommendations update once per day, cache TTL calculated as hours until midnight to expire at start of next day
- Recommendation limit: Free tier users receive 3 recommendations per day (configurable limit parameter in generateRecommendationCandidates function), premium tier can be extended in future
- Explanation generation: Generate explanations for all recommendations in parallel using Promise.all for performance, handle individual explanation failures gracefully without breaking entire feed
- Home page conditional rendering: Updated home page (`routes/index.tsx`) to show recommendation feed for authenticated users and welcome page for guests, uses handler to check authentication status and pass to component
- Recommendation feed component: Created `islands/RecommendationFeed.tsx` island component that fetches recommendations on mount, displays cards with poster images, titles, explanations, similarity scores, and links to content detail pages
- Error handling: Handle authentication errors (401), API failures, and empty states gracefully with helpful messages guiding users to watch content for recommendations
- Cache key format: Use ISO date format (YYYY-MM-DD) in cache keys for consistent daily updates across timezones, ensures recommendations refresh at midnight local time
- Client-side caching: Set Cache-Control header (private, max-age=3600) for 1-hour client-side caching to reduce API calls while maintaining freshness

## UI - Home Feed Layout Implementation

- Home feed structure: Personalised home feed includes three main sections: Recommendations (prominently displayed), Continue Watching (recent activity), and New Releases (fresh content) for authenticated users
- Continue Watching component: Created `islands/ContinueWatching.tsx` island component that fetches recently watched content from `/api/library/watched` endpoint, displays most recent 6 items in responsive grid layout
- New Releases component: Created `islands/NewReleases.tsx` island component that fetches trending content from `/api/trending` endpoint, displays first 6 items with "View All" link to browse page
- Section ordering: Recommendations section displayed first (most prominent), followed by Continue Watching, then New Releases, creating logical flow from personalised content to recent activity to discovery
- Conditional rendering: Continue Watching section only renders if user has watched content (returns null if empty), prevents empty sections from cluttering the home feed
- Grid layout consistency: All home feed sections use consistent responsive grid layout (2-6 columns based on viewport) matching library and search page patterns for visual consistency
- Section headers: Each section includes descriptive heading and subtitle explaining the content, with "View All" links where appropriate (New Releases links to browse page)
- Component isolation: Each section is a separate island component that fetches its own data independently, allowing for independent loading states and error handling

## UI - Library Tabs Implementation

- Library tabs component: Created `islands/LibraryTabs.tsx` island component that implements tabbed library view with Watched, To Watch, and Favourites tabs, plus custom lists sidebar
- Tab-based content switching: Use `useState` for activeTab and `useEffect` hook with activeTab dependency to fetch content when tab changes, ensuring efficient data loading only when needed
- Custom lists sidebar: Display custom lists in sidebar (lg:w-64) with "Create List" button, list names, item counts, and links to list detail pages, providing easy access to custom collections
- Tab navigation: Implement tab navigation using button elements with conditional styling (border-indigo-500 for active, border-transparent for inactive), providing clear visual feedback for active tab
- Content fetching pattern: Fetch content only when specific tab is active using conditional checks in useEffect, preventing unnecessary API calls and improving performance
- Responsive layout: Use flex layout (flex-col lg:flex-row) to stack sidebar above content on mobile, side-by-side on desktop, ensuring good UX across all viewport sizes
- Empty states: Display helpful empty state messages for each tab when no content exists, guiding users on how to populate their library
- Loading states: Show loading indicators while fetching content, providing feedback during data retrieval operations

## UI - Content Grid Component Implementation

- Reusable grid component: Created `components/ContentGrid.tsx` as a reusable responsive grid component for displaying content posters consistently across all pages
- Responsive breakpoints: Grid uses Tailwind CSS responsive classes: 2 columns (mobile), 3 columns (sm), 4 columns (md), 5 columns (lg), 6 columns (xl) to meet requirements of 2-3 posters on mobile and 5-6 posters on desktop
- Component composition: ContentGrid accepts children and optional className prop, allowing flexible content cards while maintaining consistent grid layout
- Grid consistency: Updated all content display pages (LibraryTabs, SearchPage, BrowsePage, ListPage) to use ContentGrid component, ensuring consistent responsive behaviour across the application
- Component location: Created `components/` directory for shared Preact components that can be used in both islands and routes, separate from `islands/` directory which contains client-side interactive components

## Security - CSRF Protection Implementation

- CSRF token utilities: Created `lib/security/csrf.ts` module with functions for generating, storing, and validating CSRF tokens using double-submit cookie pattern
- Double-submit cookie pattern: CSRF token stored in HttpOnly cookie (server-side only) and same token included in forms as hidden field, validated by comparing both tokens on submission
- Token generation: Use cryptographically secure random token generation (32 bytes, base64 encoded) for CSRF tokens, expires after 1 hour
- Cookie security: CSRF cookie uses HttpOnly, SameSite=Lax, and Secure (in production) flags for maximum security
- Constant-time comparison: Use constant-time string comparison function to prevent timing attacks when validating CSRF tokens
- Form integration: Updated login, signup, and logout forms to include CSRF tokens as hidden fields, generated on GET request and set in cookie
- Route handler pattern: GET handlers generate CSRF token and set cookie, POST handlers validate token before processing request
- API route validation: Updated login, signup, and logout API endpoints to validate CSRF tokens, return 403 Forbidden with error message if invalid
- Test script: Created `scripts/test-csrf-protection.ts` to verify CSRF protection works correctly (missing token rejected, invalid token rejected, valid token accepted)
- JSON API endpoints: JSON API endpoints (called from JavaScript) need additional CSRF token endpoint (`/api/csrf-token`) to expose token for JavaScript clients, as HttpOnly cookies cannot be read by JavaScript

## Security - Rate Limiting Implementation

- Rate limiting module: Created `lib/security/rate-limit.ts` module with functions for tracking failed authentication attempts and enforcing rate limits using sliding window approach
- Sliding window rate limiting: Track failed attempts per identifier (IP address) with timestamps, clean up old attempts outside the window (15 minutes), block after 10 failed attempts
- IP address extraction: Extract client IP from X-Forwarded-For or X-Real-IP headers (for proxies/load balancers), fallback to "unknown" if headers not available
- Rate limit configuration: 10 failed attempts per 15 minutes (configurable MAX_FAILED_ATTEMPTS and RATE_LIMIT_WINDOW_MS constants)
- Memory management: Periodic cleanup (every 5 minutes) removes old entries from in-memory store to prevent memory leaks, cleans up attempts outside window and removes entries that are no longer blocked
- Rate limit checking: Check rate limit before processing authentication requests, return 429 Too Many Requests with error message and remaining seconds if blocked
- Failed attempt tracking: Record failed attempts (invalid email, invalid password, duplicate email on signup) to track abuse patterns
- Successful authentication clearing: Clear failed attempts on successful login/signup to reset rate limit counter for legitimate users
- Error response format: Rate limit errors return 429 status with JSON body containing error message, rateLimitExceeded flag, and remainingSeconds countdown
- Authentication endpoint integration: Integrated rate limiting into login and signup endpoints, checks rate limit before processing, records failures, clears on success
- Test script: Created `scripts/test-rate-limiting.ts` to verify rate limiting works correctly (10 failed attempts trigger limit, error message indicates rate limiting, cooldown restores access)

## API Error Handling Implementation

- Error response utilities: Created `lib/api/errors.ts` module with standardised error response functions for consistent API error handling across all endpoints
- Error response format: Standardised error responses include `error` (error type), `message` (human-readable message), `details` (field-specific validation errors), and optional `code` (error code) fields
- HTTP status code helpers: Created helper functions for common status codes: `createBadRequestResponse()` (400), `createUnauthorizedResponse()` (401), `createNotFoundResponse()` (404), `createInternalServerErrorResponse()` (500), `createTooManyRequestsResponse()` (429)
- Validation error format: Validation errors use `createBadRequestResponse()` with optional field name parameter to create structured error responses with field-specific error messages in `details` object
- Catch-all 404 handler: Created `routes/api/[...path].ts` catch-all route handler that returns JSON 404 responses for any unmatched API endpoints, ensuring all API routes return consistent JSON error format
- Error response consistency: Updated all API endpoints (login, signup, search, trending, lists, rating, etc.) to use consistent error response utilities, replacing ad-hoc error response creation
- CSRF error integration: Updated CSRF error response function to use standardised error utilities for consistency with other API errors
- Error logging: Internal server error responses log errors to console for debugging while returning user-friendly error messages to clients
- Type safety: Error response functions use TypeScript interfaces (`ApiErrorResponse`, `ValidationErrorResponse`) for type-safe error response creation

## Deployment - Deno Deploy Configuration

- Deno Deploy entrypoint: Uses `main.ts` as the entrypoint file for production deployment, which imports Fresh server and starts the application
- Deployment documentation: Created comprehensive deployment guide at `docs/DEPLOYMENT.md` covering repository linking, environment variable configuration, auto-deployment setup, and troubleshooting
- Environment variables: All environment variables must be configured in Deno Deploy dashboard (DATABASE_URL, JWT_SECRET, TMDB_API_KEY, GOOGLE_OAUTH_CLIENT_ID, GOOGLE_OAUTH_CLIENT_SECRET, UPSTASH_REDIS_REST_URL, UPSTASH_REDIS_REST_TOKEN, OPENAI_API_KEY)
- Auto-deployment: Deno Deploy automatically deploys on push to configured branch (typically `main`), enabling continuous deployment workflow
- Database setup: Production database must be set up separately (e.g., Supabase, Neon, Railway) and migrations must be run before deployment
- Deployment verification: After deployment, verify production URL loads, environment variables are set correctly, and key functionality works (authentication, search, database connections)
- Rollback capability: Deno Deploy allows promoting previous deployments to rollback if issues occur
- Configuration files: `main.ts` and `fresh.config.ts` are sufficient for Deno Deploy - no additional deployment configuration files needed beyond standard Fresh setup

## UI - Mobile-Responsive Navigation Implementation

- Navigation component: Created `islands/Navigation.tsx` as an island component (requires hooks for mobile menu state) with responsive design for mobile and desktop viewports
- Mobile navigation pattern: Implemented hamburger menu for mobile viewports (below md breakpoint) with collapsible dropdown menu, desktop shows horizontal top navigation bar
- App wrapper integration: Updated `routes/_app.tsx` to include handler that extracts current path and authentication status, passes to Navigation component for conditional rendering of authenticated links
- Touch target sizing: All interactive elements (hamburger button, mobile menu links, desktop nav links) use `min-h-[44px]` and `min-w-[44px]` classes to meet 44x44px minimum touch target requirement for mobile accessibility
- Responsive breakpoints: Uses Tailwind `md:` breakpoint (768px) to switch between mobile hamburger menu and desktop horizontal navigation, ensuring optimal UX across all device sizes
- Active state indication: Navigation highlights active route using `isActive()` function that checks if current path matches or starts with link href, provides visual feedback for current page
- Conditional navigation links: Navigation shows different links based on authentication status - authenticated users see Library and Dashboard links, guests only see Home, Browse, and Search
- Mobile menu state: Uses Preact `useState` hook to manage mobile menu open/closed state, closes menu when navigation link is clicked for better UX
